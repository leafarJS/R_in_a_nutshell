c("c1", "c2", "c3", "c4")))
m
# Matrices
m <- matrix(data = 1:12,
nrow = 4,
ncol = 3,
dinmames = list(c("r1", "r2", "r3", "r4"),
c("c1", "c2", "c3", "c4")))
m
# Matrices
m <- matrix(data = 1:12,
nrow = 4,
ncol = 3,
dinmames = list(c("r1", "r2", "r3", "r4"),
c("c1", "c2", "c3")))
m
# Matrices
m <- matrix(data = 1:12,
nrow = 4,
ncol = 3,
dinmames = list(c("r1", "r2", "r3", "r4"),
c("c1", "c2", "c3")))
m
c("c1", "c2", "c3"))
m
# Matrices
m <- matrix(data = 1:12, nrow = 4, ncol = 3, dinmames = list(c("r1", "r2", "r3", "r4"), c("c1", "c2", "c3"))
m
# Matrices
m <- matrix(data = 1:12, nrow = 4, ncol = 3, dinmames = list(c("r1", "r2", "r3", "r4"), c("c1", "c2", "c3")))
m
# Matrices
m <- matrix(data = 1:12, nrow = 4, ncol = 3, dinmames = list(c("r1", "r2", "r3", "r4"), c("c1", "c2", "c3")))
# Matrices
m <- matrix(data = 1:12, nrow = 4, ncol = 3, dinmames = list(c("r1","r2","r3","r4"), c("c1","c2","c3")))
# Matrices
m <- matrix(data = 1:12, nrow = 4, ncol = 3, dimnames = list(c("r1","r2","r3","r4"), c("c1","c2","c3")))
m
# ARRAYS
a <- array(data = 1:24,
dim = c(2,4,3))
a
a <- array(data = 1:24,
dim = c(3,4,2))
a
#FACTORS
eye_colors <- c("brown", "blue", "blue", "blue", "green", "brown", "brown", "brown")
eye_colors
eye_colors <-factor(c("brown", "blue", "blue", "blue", "green", "brown", "brown", "brown"))
eye_colors
levels(eye_colors)
survey_result <-factor(c("Disagree","Neutral","Strongly Disagree",
"Neutral","Agree","Strongly Agree",
"Disagree","Strongly Agree","Neutral",
"Strongly Disagree","Neutral","Agree"),
levels = c("Strongly Disagree", "Disagree",
"Neutral", "Agree", "Strongly Agree"),
ordered = TRUE)
survey_result
#use the eye colors vector we used above
eye_colors
class(eye_colors)
#now create a vector by removing the class
eye_colors.integer.vector <- unclass(eye_colors)
eye_colors.integer.vector
attr("levels")
attr(,"levels")
class(eye_colors.integer.vector)
attr(, "levels")
class(eye_colors.integer.vector)
class(eye_colors.integer.vector) <- "factor"
eye_colors.integer.vector
class(eye_colors.integer.vector)
#error
data.frame(a = c(1,2,3,4,5),
b = c(1,2,3,4))
#correct
top.bacon.searchin.cities <- data.frame(city = c("seatle", "whasingtong", "chicago",
"new york", "porland", "st. louis",
"denver", "boston", "minneapolis",
"austin", "philadelphia", "san francisco",
"atlanta","los angeles", "ohio"),
rank = c(100,96,94,93,93,92,90,90,89,87,85,84,82,80,80))
top.bacon.searchin.cities
typeof(top.bacon.searchin.cities)
class(top.bacon.searchin.cities)
sample.formula <- as.formula(y~x1+x2+x3)
class(sample.formula)
typeof(sample.formula)
#FORMULAS
# Muy a menudo, necesita expresar una relación entre variables. A veces, desea trazar
# un gráfico que muestre la relación entre las dos variables. Otros tiempos,
# desea desarrollar un modelo matemático. R proporciona una clase de fórmula que
# le permite describir la relación para ambos propósitos.
sample.formula <- as.formula(y~x1+x2+x3)
class(sample.formula)
typeof(sample.formula)
# Nombres de variables
# Representar nombres de variables.
#
# tilde (~)
# Se utiliza para mostrar la relación entre las variables de respuesta (a la izquierda)
# y las variables de estímulo (a la derecha).
#
# Signo más (+)
# Se utiliza para expresar una relación lineal entre variables.
#
# cero (0)
# Cuando se agrega a una fórmula, indica que no se debe incluir ningún término de intercepción.
# Por ejemplo:
#
#     y~u+w+v+0
#
# Barra vertical (|)
# Se utiliza para especificar variables condicionantes (en fórmulas reticulares)
#
# Función de identidad (I())
# Se utiliza para indicar que la expresión adjunta debe interpretarse según su
# significado aritmético. Por ejemplo:
#   a+b
# significa que tanto a como b deben incluirse en la fórmula. La formula:
#   yo(a+b)
# significa que "a más b" debe incluirse en la fórmula.
# Asterisco (*)
# Se utiliza para indicar interacciones entre variables. Por ejemplo:
#   y~(u+v)*w
# es equivalente a:
#   y~u+v+w+I(u*w)+I(v*w)
# Intercalación (^)
# Se utiliza para indicar el cruce en un grado específico. Por ejemplo:
#   y~(u+w)^2
# es equivalente a:
#   y~(u+w)*(u+w)
# Función de variables
# Indica que la función de las variables especificadas debe interpretarse como una
# variable. Por ejemplo:
#   y~log(u)+sin(v)+w
class(fo <- y ~ x1*x2) # "formula"
fo
typeof(fo)  # R internal : "language"
terms(fo)
environment(fo)
environment(as.formula("y ~ x"))
environment(as.formula("y ~ x", env = new.env()))
## Create a formula for a model with a large number of variables:
xnam <- paste0("x", 1:25)
(fmla <- as.formula(paste("y ~ ", paste(xnam, collapse= "+"))))
fo
typeof(fo)  # R internal : "language"
terms(fo)
environment(fo)
environment(as.formula("y ~ x"))
environment(as.formula("y ~ x", env = new.env()))
## Create a formula for a model with a large number of variables:
xnam <- paste0("x", 1:25)
(fmla <- as.formula(paste("y ~ ", paste(xnam, collapse= "+"))))
ts(data = NA,
start = 1,
end = numeric(0),
frequency = 1,
deltat = 1,
ts.eps = getOption("ts.eps"),
class = c("mts"),
names = "serie.1")
ts(data = NA,
start = 1,
end = numeric(10),
frequency = 1,
deltat = 1,
ts.eps = getOption("ts.eps"),
class = c("mts"),
names = "serie.1")
ts(data = NA, start = 1, end = numeric(0), frequency = 1,
deltat = 1, ts.eps = getOption("ts.eps"), class = , names = )
ts(data = 1:10, start = 1, end = numeric(0), frequency = 1,
deltat = 1, ts.eps = getOption("ts.eps"), class = , names = )
ts(1:8, start=c(2008, 2), frequency=4)
ts(1:8, start=c(2008, 2), frequency=4, class = c("mts"))
install.packages("nutshell")
#install.packages("nutshell")
library(nutshell)
install.packages("nutshell")
library(nutshell)
install.packages("nutshell")
install.packages("MASS")
install.packages("RSQLite")
install.packages("arules")
install.packages("lattice")
install.packages("survival")
install.packages("nutshell.bbdb")
load("C:/Users/Administrador/Desktop/R_in_a_Nutshell/data/batting.2008.rda")
load("C:/Users/Administrador/Desktop/R_in_a_Nutshell/data/batting.2008.rda")
View(batting.2008)
View(batting.2008)
mis.datos<-import("data/batting.2008.rda")
mis.datos<-load("data/batting.2008.rda")
View(mis.datos)
load("C:/Users/Administrador/Desktop/R_in_a_Nutshell/data/batting.2008.rda")
View(batting.2008)
df_desiguales_rds <- read_rda("data/batting.2008.rds")
df_desiguales_rds <- read_rds("data/batting.2008.rds")
library(tidyverse)
df_desiguales_rds <- read_rds("data/desiguales.rds")
df_desiguales_rds <- read_rds("data/batting.2008.rda")
df_desiguales_rds <- read_rda("data/batting.2008.rda")
turkey.price.ts <- read.table("C:/Users/Administrador/Desktop/R_in_a_Nutshell/data/turkey.price.ts.rda", quote="\"", stringsAsFactors=TRUE)
View(turkey.price.ts)
load("C:/Users/Administrador/Desktop/R_in_a_Nutshell/data/turkey.price.ts.rda")
load("C:/Users/Administrador/Desktop/R_in_a_Nutshell/data/shiller.rda")
View(shiller.index)
View(shiller.other.data)
load("C:/Users/Administrador/Desktop/R_in_a_Nutshell/data/turkey.price.ts.rda")
dat <-load("C:/Users/Administrador/Desktop/R_in_a_Nutshell/data/turkey.price.ts.rda")
view(data)
data(turkey.price.ts)
turkey.price.ts
data(turkey.price.ts)
turkey.price.ts
library(tidyverse)
data(turkey.price.ts)
turkey.price.ts
data <- data(turkey.price.ts)
view(data)
data(turkey.price.ts)
view(data)
turkey.price.ts
data(turkey.price.ts)
turkey.price.ts
class(turkey.price.ts)
start(turkey.price.ts)
end(turkey.price.ts)
frequency(turkey.price.ts)
deltat(turkey.price.ts)
data <- list(turkey.price.ts)
view(data)
data("turkey.price.ts")
turkey.price.ts
#R incluye una variedad de funciones de utilidad para observar objetos de series temporales:
start(turkey.price.ts)
end(turkey.price.ts)
frequency(turkey.price.ts)
deltat(turkey.price.ts)
data.I.stated.writing <- as.Date("01/10/2022", "%m/%d/%Y")
data.I.stated.writing
today <- Sys.Date()
today
data.I.stated.writing <- as.Date("31/12/2022", "%m/%d/%Y")
data.I.stated.writing
today <- Sys.Date()
today
today - data.I.stated.writing
data.I.stated.writing <- as.Date("01/01/2022", "%m/%d/%Y")
data.I.stated.writing
today <- Sys.Date()
today
today - data.I.stated.writing
class(data.I.stated.writing)
consumption.connection <- gzfile(description="consumption.RData",open="r")
consumption.connection <- gzfile(description="data/consumption.rda",open="r")
load(consumption.connection)
consumption.connection <- gzfile(description="data/consumption.rda",open="r")
data(consumption.connection)
close(consumption.connection)
consumption.connection
#CONNECTIONS
# Conexiones
# R incluye un tipo de objeto especial para recibir datos de (o enviar datos a)
# aplicaciones o archivos fuera del entorno R. (Las conexiones son como punteros
# de archivos en C o identificadores de archivos en Perl). Puede crear conexiones
# a archivos, URL, archivos comprimidos zip, archivos comprimidos gzip, archivos
# comprimidos bzip, conductos de Unix, sockets de red y FIFO (primero en entrar,
# primero en salir) objetos. Incluso puede leer desde el Portapapeles del sistema
# (para pegar datos en R).
consumption.connection <- gzfile(description="consumption.rda",open="r")
data(consumption.connection)
consumption.connection
#CONNECTIONS
# Conexiones
# R incluye un tipo de objeto especial para recibir datos de (o enviar datos a)
# aplicaciones o archivos fuera del entorno R. (Las conexiones son como punteros
# de archivos en C o identificadores de archivos en Perl). Puede crear conexiones
# a archivos, URL, archivos comprimidos zip, archivos comprimidos gzip, archivos
# comprimidos bzip, conductos de Unix, sockets de red y FIFO (primero en entrar,
# primero en salir) objetos. Incluso puede leer desde el Portapapeles del sistema
# (para pegar datos en R).
consumption.connection <- gzfile(description="data/consumption.rda", open="r")
consumption.connection
read(consumption.connection)
close(consumption.connection)
class(consumption.connection)
comment(consumption.connection)
dim(consumption.connection)
dimnames(consumption.connection)
row.names(consumption.connection)
tsp(consumption.connection)
levels(consumption.connection)
m <- matrix(data = 1:12,
nrow = 4,
ncol = 3,
dimnames = list(c("r1","r2","r3","r4"),
c("c1","c2","c3")))
attributes(m)
dim(m)
colnames(m)
rownames(m)
dim(m) <- NULL
m
class(m)
typeof(m)
class(m)
m <- matrix(data = 1:12,
nrow = 4,
ncol = 3,
dimnames = list(c("r1","r2","r3","r4"),
c("c1","c2","c3")))
class(m)
attributes(m)
dim(m)
colnames(m)
rownames(m)
dim(m) <- NULL
m
class(m)
typeof(m)
a <- array(1:12, dim = c(3,4))
a
b <- 1:12
b
a[2,2]
b[2,2]
a == b
all.equal(a, b)
identical(a, b) # false
dim(b) <- c(3,4)
a[2,2]
b[2,2]
all.equal(a, b)
all.equal(a, b)
identical(a, b)
x <- c(1,2,3,4,5)
typeof(x)
class(x)
#now create a vector by removing the class
eye_colors.integer.vector <- unclass(eye_colors)
eye_colors.integer.vector
#FACTORS
eye_colors <- c("brown", "blue", "blue", "blue", "green", "brown", "brown", "brown")
eye_colors
eye_colors <-factor(c("brown", "blue", "blue", "blue", "green", "brown", "brown", "brown"))
#The levels function shows all the levels from a factor:
eye_colors
levels(eye_colors)
#Para sortear estos problemas, puede usar un factor ordenado para representar
#la respuesta de esta encuesta. Aquí hay un ejemplo:
survey_result <-factor(c("Disagree","Neutral","Strongly Disagree",
"Neutral","Agree","Strongly Agree",
"Disagree","Strongly Agree","Neutral",
"Strongly Disagree","Neutral","Agree"),
levels = c("Strongly Disagree", "Disagree",
"Neutral", "Agree", "Strongly Agree"),
ordered = TRUE)
survey_result
#use the eye colors vector we used above
eye_colors
class(eye_colors)
#now create a vector by removing the class
eye_colors.integer.vector <- unclass(eye_colors)
eye_colors.integer.vector
attr(,"levels")
#FACTORS
eye_colors <- c("brown", "blue", "blue", "blue", "green", "brown", "brown", "brown")
eye_colors
eye_colors <-factor(c("brown", "blue", "blue", "blue", "green", "brown", "brown", "brown"))
#The levels function shows all the levels from a factor:
eye_colors
levels(eye_colors)
#Para sortear estos problemas, puede usar un factor ordenado para representar
#la respuesta de esta encuesta. Aquí hay un ejemplo:
survey_result <-factor(c("Disagree","Neutral","Strongly Disagree",
"Neutral","Agree","Strongly Agree",
"Disagree","Strongly Agree","Neutral",
"Strongly Disagree","Neutral","Agree"),
levels = c("Strongly Disagree", "Disagree",
"Neutral", "Agree", "Strongly Agree"),
ordered = TRUE)
survey_result
#use the eye colors vector we used above
eye_colors
class(eye_colors)
#now create a vector by removing the class
eye_colors.integer.vector <- unclass(eye_colors)
eye_colors.integer.vector
#attr(,"levels")
class(eye_colors.integer.vector)
#t’s possible to change this back to a factor by setting the class attribute:
class(eye_colors.integer.vector) <- "factor"
eye_colors.integer.vector
class(eye_colors.integer.vector)
eye_colors.integer.vector
attr(, "levels")
v <- as.integer(c(1,1,1,2,1,2,2,3,1))
levels(v) <- c("what", "who", "why")
class(v) <- "factor"
v
class(quote(x))
typeof(quote(x))
x <- 1
x <- 1
x <- 2
x <- 3
v <- c(x, y, z)
v
x <- 1
y <- 2
z <- 3
v <- c(x, y, z)
v
# has already defined, so chaging x does not change v
x <- 10
v
x <- 4
y <- 5
z <- 7
v <- quote(c(x, y, z))
v
eval(v)
x <- 8
eval(v)
x <- 10
y <- 11
z <- 12
delayedAssign("v", c("x", "y", "z"))
eval(delayedAssign())
delayedAssign("v", c("x", "y", "z"))
x <- 0
v
x <- 10
y <- 11
z <- 12
delayedAssign("v", c("x", "y", "z"))
x <- 0
v
x <- 4
y <- 5
z <- 7
v <- quote(c(x, y, z))
v
eval(v)
x <- 8
eval(v)
# También es posible crear un objeto de promesa en R para retrasar la evaluación
# de una variable hasta que se necesite (por primera vez). Puede crear un objeto
# de promesa a través de la función delayAssign:
#x <- 10
#y <- 11
#z <- 12
delayedAssign("v", c("x", "y", "z"))
x <- 0
v
x <- 4
y <- 5
z <- 7
v <- quote(c(x, y, z))
v
eval(v)
x <- 8
eval(v)
# También es posible crear un objeto de promesa en R para retrasar la evaluación
# de una variable hasta que se necesite (por primera vez). Puede crear un objeto
# de promesa a través de la función delayAssign:
#x <- 10
#y <- 11
#z <- 12
delayedAssign("v", c("x", "y", "z"))
x <- 0
v
x <- 1
y <- 2
z <- 3
v <- c(x, y, z)
v
# has already defined, so chaging x does not change v
x <- 10
v
# Es posible retrasar la evaluación de una expresión para que los símbolos no se
# evalúen inmediatamente:
x <- 4
y <- 5
z <- 7
v <- quote(c(x, y, z))
v
eval(v)
x <- 8
eval(v)
# También es posible crear un objeto de promesa en R para retrasar la evaluación
# de una variable hasta que se necesite (por primera vez). Puede crear un objeto
# de promesa a través de la función delayAssign:
#x <- 10
#y <- 11
#z <- 12
delayedAssign("v", c("x", "y", "z"))
x <- 0
v
delayedAssign("v", c(x, y, z))
x <- 0
v
x <- 10
y <- 11
z <- 12
delayedAssign("v", c(x, y, z))
x <- 0
v
